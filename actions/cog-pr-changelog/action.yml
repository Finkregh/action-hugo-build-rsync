# SPDX-License-Identifier: MIT
# yaml-language-server: $schema=https://www.schemastore.org/github-action.json
name: "Cocogitto PR Changelog"
author: "Oluf Lorenzen <ol+forgejo-action@oluflorenzen.de>"
description: |
  Generates a changelog using cocogitto and posts it as a comment to a Pull Request.

  This action generates a changelog for the changes in a PR using cocogitto's conventional commit parsing,
  then posts the changelog as a comment on the PR. If a changelog comment already exists, it updates that comment.

inputs:
  # Changelog generation options
  changelog_pattern:
    description: 'Generate the changelog in the given spec range (e.g., "HEAD~10..HEAD", "v1.0.0..HEAD")'
    required: false
    default: "origin/${{ env.GITHUB_BASE_REF }}..HEAD"

  changelog_template:
    description: 'Template to use for changelog generation. Possible values: "remote", "full_hash", "default", or path to custom template'
    required: false
    default: "default"

  changelog_remote:
    description: "URL to use during template generation"
    required: false

  changelog_owner:
    description: "Repository owner to use during template generation"
    required: false

  changelog_repository:
    description: "Name of the repository used during template generation"
    required: false

  # Comment configuration
  comment_header:
    description: "Header text for the changelog comment"
    required: false
    default: "## ðŸ“‹ Changelog"

  comment_footer:
    description: "Footer text for the changelog comment"
    required: false
    default: "*Generated by [cocogitto](https://github.com/cocogitto/cocogitto)*"

  # Forgejo/Git Configuration
  forgejo_server_url:
    description: "Forgejo server URL for API calls"
    required: false
    default: "${{ env.GITHUB_SERVER_URL }}"

  forgejo_token:
    description: "Forgejo API token"
    required: false
    default: "${{ env.GITHUB_TOKEN }}"

  forgejo_curl_source:
    description: "Where to download the forgejo-curl script"
    required: false
    default: "https://git.h.oluflorenzen.de/mirrors/forgejo-curl/raw/branch/main/forgejo-curl.sh"

outputs:
  changelog:
    description: "Generated changelog content"
    value: "${{ steps.generate_changelog.outputs.changelog }}"
  current_version:
    description: "Current version determined by cocogitto"
    value: "${{ steps.determine_version.outputs.current_version }}"
  next_version:
    description: "Next version that would be created by cocogitto"
    value: "${{ steps.determine_version.outputs.next_version }}"
  comment_id:
    description: "ID of the created or updated comment"
    value: "${{ steps.post_comment.outputs.comment_id }}"
  comment_url:
    description: "URL of the created or updated comment"
    value: "${{ steps.post_comment.outputs.comment_url }}"

runs:
  using: "composite"
  steps:
    - name: Extract branch name
      shell: bash
      run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> "$GITHUB_OUTPUT"
      id: extract_branch

    - name: Checkout
      id: checkout
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
        ref: ${{ steps.extract_branch.outputs.branch }}

    - name: Install dependencies
      shell: bash
      run: |
        echo "::group::Installing dependencies"
        apt-get update
        apt-get install -y jq curl
        echo "::endgroup::"

    - name: Install cocogitto
      uses: https://git.h.oluflorenzen.de/mirrors/codeberg.PurpleBooth.common-pipelines/actions/install-cocogitto@main

    - name: Determine next version
      id: determine_version
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::Determining next version with cocogitto"

        # Get current version
        CURRENT_VERSION=""
        if CURRENT_VERSION=$(cog get-version 2>/dev/null); then
          echo "Current version: $CURRENT_VERSION"
        else
          echo "::warning::Could not determine current version, assuming 0.0.0"
          CURRENT_VERSION="0.0.0"
        fi

        # Determine next version using auto bump with dry-run
        NEXT_VERSION=""
        if NEXT_VERSION=$(cog bump --auto --dry-run 2>/dev/null); then
          echo "Next version would be: $NEXT_VERSION"
        else
          echo "::warning::Could not determine next version, no conventional commits found"
          NEXT_VERSION="No version bump needed"
        fi

        # Save version info to outputs
        echo "current_version=$CURRENT_VERSION" >> "$GITHUB_OUTPUT"
        echo "next_version=$NEXT_VERSION" >> "$GITHUB_OUTPUT"

        echo "::endgroup::"

    - name: Generate changelog
      id: generate_changelog
      shell: bash
      run: |
        set -euo pipefail
        echo "::group::Generating changelog with cocogitto"

        # Build cog changelog command
        COG_CMD="cog changelog"

        # Add pattern if specified
        CHANGELOG_PATTERN="${{ inputs.changelog_pattern }}"
        if [ -n "$CHANGELOG_PATTERN" ]; then
          COG_CMD="$COG_CMD $CHANGELOG_PATTERN"
        fi

        # Add template option
        CHANGELOG_TEMPLATE="${{ inputs.changelog_template }}"
        if [ -n "$CHANGELOG_TEMPLATE" ]; then
          COG_CMD="$COG_CMD --template $CHANGELOG_TEMPLATE"
        fi

        # Add remote option
        CHANGELOG_REMOTE="${{ inputs.changelog_remote }}"
        if [ -n "$CHANGELOG_REMOTE" ]; then
          COG_CMD="$COG_CMD --remote $CHANGELOG_REMOTE"
        fi

        # Add owner option
        CHANGELOG_OWNER="${{ inputs.changelog_owner }}"
        if [ -n "$CHANGELOG_OWNER" ]; then
          COG_CMD="$COG_CMD --owner $CHANGELOG_OWNER"
        fi

        # Add repository option
        CHANGELOG_REPOSITORY="${{ inputs.changelog_repository }}"
        if [ -n "$CHANGELOG_REPOSITORY" ]; then
          COG_CMD="$COG_CMD --repository $CHANGELOG_REPOSITORY"
        fi

        echo "Running: $COG_CMD"

        # Generate changelog and capture output
        CHANGELOG_OUTPUT=""
        if CHANGELOG_OUTPUT=$(eval "$COG_CMD" 2>&1); then
          echo "Changelog generated successfully"
        else
          echo "::warning::Failed to generate changelog with cocogitto, using fallback"
          CHANGELOG_OUTPUT="No conventional commits found in the specified range."
        fi

        # Save changelog to output and file
        echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
        echo "$CHANGELOG_OUTPUT" >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"

        # Also save to a file for easier handling
        echo "$CHANGELOG_OUTPUT" > /tmp/changelog.md

        echo "::endgroup::"

    - name: Install forgejo-curl helper
      shell: bash
      run: |
        echo "::group::Installing forgejo-curl helper"
        curl --fail -sS -o /usr/local/bin/forgejo-curl.sh "${{ inputs.forgejo_curl_source }}" && chmod +x /usr/local/bin/forgejo-curl.sh
        export PATH=/usr/local/bin:$PATH
        forgejo-curl.sh --token "${{ inputs.forgejo_token }}" login "${{ inputs.forgejo_server_url }}"
        echo "::endgroup::"

    - name: Post or update PR comment
      id: post_comment
      shell: bash
      if: github.event_name == 'pull_request'
      run: |
        set -euo pipefail
        echo "::group::Posting or updating PR comment"

        export PATH=/usr/local/bin:$PATH

        # Read the changelog content
        CHANGELOG_CONTENT=$(cat /tmp/changelog.md)

        # Get version information from previous step
        CURRENT_VERSION="${{ steps.determine_version.outputs.current_version }}"
        NEXT_VERSION="${{ steps.determine_version.outputs.next_version }}"

        # Create the full comment body with version info and proper escaping
        cat > /tmp/comment_body.txt << 'COMMENT_EOF'
        ${{ inputs.comment_header }}

        **ðŸ“¦ Version Information**
        - Current version: `CURRENT_VERSION_PLACEHOLDER`
        - Next version: `NEXT_VERSION_PLACEHOLDER`

        COMMENT_EOF
        cat /tmp/changelog.md >> /tmp/comment_body.txt
        cat >> /tmp/comment_body.txt << 'COMMENT_EOF'

        ${{ inputs.comment_footer }}
        COMMENT_EOF

        # Replace version placeholders with actual values
        sed -i "s/CURRENT_VERSION_PLACEHOLDER/$CURRENT_VERSION/g" /tmp/comment_body.txt
        sed -i "s/NEXT_VERSION_PLACEHOLDER/$NEXT_VERSION/g" /tmp/comment_body.txt

        COMMENT_BODY=$(cat /tmp/comment_body.txt)

        # Check if a changelog comment already exists
        COMMENT_IDENTIFIER="${{ inputs.comment_header }}"
        EXISTING_COMMENT_ID=""

        echo "Checking for existing changelog comment..."
        COMMENTS_RESPONSE=$(forgejo-curl.sh api "${{ inputs.forgejo_server_url }}/api/v1/repos/${{ github.repository }}/issues/${{ github.event.number }}/comments")

        # Parse JSON to find existing comment with our identifier
        if echo "$COMMENTS_RESPONSE" | grep -q "$COMMENT_IDENTIFIER"; then
          EXISTING_COMMENT_ID=$(echo "$COMMENTS_RESPONSE" | jq -r ".[] | select(.body | contains(\"$COMMENT_IDENTIFIER\")) | .id" | head -n1)
          echo "Found existing comment with ID: $EXISTING_COMMENT_ID"
        fi

        if [ -n "$EXISTING_COMMENT_ID" ] && [ "$EXISTING_COMMENT_ID" != "null" ]; then
          # Update existing comment
          echo "Updating existing comment..."
          RESPONSE=$(forgejo-curl.sh api_json --request PATCH --data-raw "{\"body\":$(echo "$COMMENT_BODY" | jq -Rs .)}" \
            "${{ inputs.forgejo_server_url }}/api/v1/repos/${{ github.repository }}/issues/comments/$EXISTING_COMMENT_ID")
          COMMENT_ID="$EXISTING_COMMENT_ID"
        else
          # Create new comment
          echo "Creating new comment..."
          RESPONSE=$(forgejo-curl.sh api_json --data-raw "{\"body\":$(echo "$COMMENT_BODY" | jq -Rs .)}" \
            "${{ inputs.forgejo_server_url }}/api/v1/repos/${{ github.repository }}/issues/${{ github.event.number }}/comments")
          COMMENT_ID=$(echo "$RESPONSE" | jq -r '.id')
        fi

        # Extract comment URL
        COMMENT_URL=$(echo "$RESPONSE" | jq -r '.html_url // empty')
        if [ -z "$COMMENT_URL" ]; then
          COMMENT_URL="${{ inputs.forgejo_server_url }}/${{ github.repository }}/pulls/${{ github.event.number }}#issuecomment-$COMMENT_ID"
        fi

        echo "comment_id=$COMMENT_ID" >> "$GITHUB_OUTPUT"
        echo "comment_url=$COMMENT_URL" >> "$GITHUB_OUTPUT"

        echo "::notice::Changelog comment posted/updated: $COMMENT_URL"
        echo "::endgroup::"

    - name: Handle non-PR events
      shell: bash
      if: github.event_name != 'pull_request'
      run: |
        echo "::notice::This action is designed for pull requests. Current event: ${{ github.event_name }}"

branding:
  icon: "message-circle"
  color: "purple"
