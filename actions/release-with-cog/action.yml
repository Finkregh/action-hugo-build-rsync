---
name: Release using Cog
description: Release using Cog, and output the version before run, the version after run, and the changelog are emitted
# fork from <https://codeberg.org/PurpleBooth/common-pipelines/src/branch/main/actions/release-with-cog>
# License: CC0 1.0 Universal, <https://codeberg.org/PurpleBooth/common-pipelines/src/branch/main/LICENSE>
inputs:
  working-directory:
    description: The working dir to run in
    default: "."
  dry-run:
    description: If true, no git tag or commit will be created
    default: "false"
    required: false
  dry-run-on-non-default-branch:
    description: If true, no git tag or commit will be created if not on default branch
    default: "true"
    required: false
  cog_bump_args:
    description: Additional arguments to pass to `cog bump`, e.g. `--major` or `--minor`
    default: ""
    required: false
  cog_changelog_args:
    description: Additional arguments to pass to `cog changelog`, e.g. `--unreleased`
    default: "--remote ${{ env.GITHUB_SERVER_URL##*/ }} --owner ${{ env.GITHUB_REPOSITORY_OWNER }} --repo ${{ env.GITHUB_REPOSITORY##*/ }}"
  create-forgejo-release:
    description: If true, create a Forgejo release for the new tag
    default: "true"
    required: false
outputs:
  current_version:
    value: ${{ steps.current_version.outputs.current_version }}
    description: The version after the bump
  previous_version:
    value: ${{ steps.previous_version.outputs.previous_version }}
    description: The version prior to bump
  changelog:
    value: ${{ steps.changelog.outputs.changelog }}
    description: Changelog since last release in markdown
  forgejo_release_url:
    value: ${{ fromJson(steps.create_forgejo_release.outputs.forgejo_release_output).html_url }}
    description: |
      URL of the created Forgejo release.
      Example: https://forgejo.example.com/owner/repo/releases/tag/v1.2.3
  forgejo_release_output:
    value: ${{ steps.create_forgejo_release.outputs.forgejo_release_output }}
    description: |
      Output from the Forgejo API when creating the release.
      Example:
        {
          "archive_download_count": {
            "tar_gz": 0,
            "zip": 0
          },
          "assets": [
            {
              "browser_download_url": "string",
              "created_at": "2025-09-26T21:19:45.046Z",
              "download_count": 0,
              "id": 0,
              "name": "string",
              "size": 0,
              "type": "attachment",
              "uuid": "string"
            }
          ],
          "author": {
            "active": true,
            "avatar_url": "string",
            "created": "2025-09-26T21:19:45.046Z",
            "description": "string",
            "email": "user@example.com",
            "followers_count": 0,
            "following_count": 0,
            "full_name": "string",
            "html_url": "string",
            "id": 0,
            "is_admin": true,
            "language": "string",
            "last_login": "2025-09-26T21:19:45.046Z",
            "location": "string",
            "login": "string",
            "login_name": "empty",
            "prohibit_login": true,
            "pronouns": "string",
            "restricted": true,
            "source_id": 0,
            "starred_repos_count": 0,
            "visibility": "string",
            "website": "string"
          },
          "body": "string",
          "created_at": "2025-09-26T21:19:45.046Z",
          "draft": true,
          "hide_archive_links": true,
          "html_url": "string",
          "id": 0,
          "name": "string",
          "prerelease": true,
          "published_at": "2025-09-26T21:19:45.046Z",
          "tag_name": "string",
          "tarball_url": "string",
          "target_commitish": "string",
          "upload_url": "string",
          "url": "string",
          "zipball_url": "string"
        }

runs:
  using: composite
  steps:
    - id: dryrun-arg
      name: Set dry-run arg
      run: |
        if [[ "${{ inputs.dry-run }}" == "true" ]] && [[ "${{ env.GITHUB_HEAD_REF }}" == "${{ env.GITHUB_BASE_REF }}" ]]; then
          echo "arg=--dry-run" >> "$GITHUB_OUTPUT"
        elif [[ "${{ inputs.dry-run-on-non-default-branch }}" == "true" ]] && [[ "${{ env.GITHUB_HEAD_REF }}" != "${{ env.GITHUB_BASE_REF }}" ]]; then
          echo "arg=--dry-run" >> "$GITHUB_OUTPUT"
        else
          echo "arg=" >> "$GITHUB_OUTPUT"
        fi
        echo "::notice::Set output $(cat "$GITHUB_OUTPUT")"
      shell: bash
    - id: previous_version
      name: Output previous_version
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "::group::Determine previous version"
        pushd "$WORK_DIR" || exit 1
        cog get-version
        echo "previous_version=$( cog get-version 2>/dev/null )"  >> "$GITHUB_OUTPUT"
        popd || exit 1
        echo "::endgroup::"
      shell: bash
    - name: Semver release
      id: release
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Running this: cog bump ${{ input.cog_bump_args }} ${{ steps.dryrun-arg.outputs.arg }} --auto --skip-ci"
        cog bump ${{ input.cog_bump_args }} ${{ steps.dryrun-arg.outputs.arg }} --auto --skip-ci || true
      continue-on-error: true
    - id: current_version
      working-directory: ${{ inputs.working-directory }}
      name: Output current_version
      run: |
        cog get-version
        echo "current_version=$( cog get-version 2>/dev/null )"  >> "$GITHUB_OUTPUT"
      shell: bash
    - id: changelog
      name: Output changelog
      working-directory: ${{ inputs.working-directory }}
      run: |
        echo "Generating changelog with: cog ${{ input.cog_changelog_args }} changelog --at \"$(yq -o csv '.tag_prefix // ""' cog.toml)""$(cog get-version 2>/dev/null)\""
        echo 'changelog<<EOF' >> "$GITHUB_OUTPUT"
        cog ${{ input.cog_changelog_args }} changelog --at "$(yq -o csv '.tag_prefix // ""' cog.toml)""$(cog get-version 2>/dev/null)" >> "$GITHUB_OUTPUT"
        echo 'EOF' >> "$GITHUB_OUTPUT"
      shell: bash
    - id: install-jo
      name: Install jo
      if: ${{ inputs.create-forgejo-release == 'true' && steps.release.outcome == 'success' && steps.current_version.outputs.current_version != '' }}
      shell: bash
      run: |
        echo "::group::Install jo"
        apt-get update
        apt-get install -y jo
        echo "::endgroup::"
    - id: install-forgejo-curl
      name: Install helper script
      if: ${{ inputs.forgejo_server_url != '' && inputs.forgejo_token != '' }} && ${{ steps.install-jo.outcome == 'success' }}
      shell: bash
      env:
        FORGEJO_TOKEN: ${{ inputs.forgejo_token }}
        FORGEJO_SERVER_URL: ${{ inputs.forgejo_server_url }}
      run: |
        echo "::startgroup::Install forgejo-curl.sh and login"
        curl --fail -sS -o /usr/local/bin/forgejo-curl.sh "https://git.h.oluflorenzen.de/mirrors/forgejo-curl/raw/branch/main/forgejo-curl.sh" && chmod +x /usr/local/bin/forgejo-curl.sh
        export PATH=/usr/local/bin:$PATH
        forgejo-curl.sh --token "${{ env.FORGEJO_TOKEN }}" login ${{ env.FORGEJO_SERVER_URL }}
        forgejo-curl.sh api_json ${{ env.FORGEJO_SERVER_URL }}/api/v1/user
        echo "::endgroup::"

    - name: Create Forgejo release with the generated changelog
      if: ${{ steps.install-jo.outcome == 'success' }}
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        CHANGELOG="${{ steps.changelog.outputs.changelog }}"
        VERSION="${{ steps.current_version.outputs.current_version }}"
        JSON_PAYLOAD=$(jo name="$VERSION" tag_name="$VERSION" body="$(echo "$CHANGELOG" | jq -R .)")
        FORGEJO_API_RETURN=$(forgejo-curl.sh --verbose api_json --data-raw "${JSON_PAYLOAD}" "${{ env.GITHUB_SERVER_URL }}/api/v1/repos/${{ env.GITHUB_REPOSITORY }}/releases")
        echo "Forgejo API response: $FORGEJO_API_RETURN"
        echo "forgejo_release_output<<EOF" >> "$GITHUB_OUTPUT"
        echo "$FORGEJO_API_RETURN" >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"
